// ще направим свържем предните стойности на N със следващите стойности на N под формата на граф
// ако по време на намирането на новите стойности на N се окаже, че имаме търсената стойност, ще прекратим
// цикъла и ще кажем колко стъпки ни е отнело, за да стигнем до тук, ако приключим обхождането преди да сме намерили
// исканата стойност, ще изведем -1, защото е невъзможно да стигнем до нея 
#include <iostream>
#include <vector>
#include <queue>
#include <map>

using namespace std;
int bfs(int N, int P, int A, int B, int R){
    queue<int>q;
    map<int, int>used;// ще използваме map, за да добавяме новите стойности в него и това колко стъпки ни е отнело
    // за да стигнем до тях, което е стойността на used за предната стойност + 1
    q.push(N);
    used[N] = 0;
    // за първата стойност е 0 и я добавяме в опашката
    while(!q.empty()){
        int v = q.front();
        q.pop();
        // изчисляваме новите ни стойности, проверяваме дали са търсените, ако са, приключваме програмата и връщаме броя стъпки
        int v1 = (v + A) % P;
        int v2 = (v + B) % P;
        if(v1 == R || v2 == R){
            return used[v] + 1;
        }
        // ако не са, искаме да ги добавим към used
        // ако ги няма в used, добавяме ги, добавяме ги към опашката за обхождане и отбелязваме, че минималният брой
        // стъпки, за да стигнем до тях е предната стойност на used[N] + 1 
        map<int, int>::iterator it = used.find(v1);
        if(it == used.end()){
            q.push(v1);
            used[v1] = used[v] + 1;
        }
        it = used.find(v2);
        if(it == used.end()){
            q.push(v2);
            used[v2] = used[v] + 1;
        }
    }
    // ако сме приключили обхождането, но не сме намерили търсената стойност, връщаме -1, защото е невъзможно
    return -1;
}
int main(){
    int N, P, A, B, R;
    cin >> N >> P;
    cin >> A >> B >> R;
    cout << bfs(N, P, A, B, R);
    return 0;
}